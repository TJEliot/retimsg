#!/usr/bin/env python3
"""
RetiMsg Daemon - Minimalist LXMF message handler for Reticulum
Runs in background, receives messages, queues outgoing messages.
"""

import RNS
import LXMF
import os
import sys
import json
import time
import signal
import socket
import logging
from datetime import datetime
from pathlib import Path
from retimsg_utils import clean_hash, MAX_MESSAGE_SIZE, MAX_SOCKET_DATA

# Version for config file format
CONFIG_VERSION = "1.0"

class RetiMsgDaemon:
    def __init__(self):
        self.config_dir = Path.home() / ".retimsg"
        self.config_file = self.config_dir / "config.json"
        self.messages_file = self.config_dir / "messages.jsonl"
        self.socket_path = self.config_dir / "daemon.sock"
        self.pid_file = self.config_dir / "daemon.pid"
        
        # Ensure config directory exists
        self.config_dir.mkdir(exist_ok=True)
        
        # Setup logging to file
        log_file = self.config_dir / "daemon.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler(log_file),
            ]
        )
        self.logger = logging.getLogger(__name__)
        
        # Load or create config
        self.config = self._load_config()
        
        # Initialize Reticulum and LXMF
        self.reticulum = None
        self.router = None
        self.identity = None
        self.destination = None
        self.running = True
        
    def _load_config(self):
        """Load config or create default with version tracking"""
        username = os.getenv("USER") or "retimsg"
        default_identity_path = str(Path.home() / ".reticulum" / "identities" / username)
        
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                config = json.load(f)
            
            # Check version and migrate if needed
            config_version = config.get("version", "0.0")
            
            if config_version != CONFIG_VERSION:
                self.logger.info(f"Migrating config from version {config_version} to {CONFIG_VERSION}")
                config = self._migrate_config(config, config_version)
                self._save_config(config)
            
            # Add identity_path if missing (backward compatibility)
            if "identity_path" not in config:
                config["identity_path"] = default_identity_path
                self._save_config(config)
            
            return config
        else:
            config = {
                "version": CONFIG_VERSION,
                "active_conversation": None,
                "identity_path": default_identity_path
            }
            self._save_config(config)
            return config
    
    def _migrate_config(self, config, from_version):
        """Migrate config from old version to current version"""
        # Set version
        config["version"] = CONFIG_VERSION
        
        # Future migrations go here
        # if from_version < "1.1":
        #     # Add new fields, convert formats, etc.
        
        return config
    
    def _save_config(self, config=None):
        """Save config to disk atomically"""
        if config is None:
            config = self.config
        
        # Write to temporary file first
        temp_file = self.config_file.with_suffix('.tmp')
        with open(temp_file, 'w') as f:
            json.dump(config, f, indent=2)
        
        # Atomic rename
        temp_file.replace(self.config_file)
    
    def _log_message(self, from_hash, to_hash, text, outgoing=False):
        """Append message to JSONL log atomically"""
        msg = {
            "timestamp": int(time.time()),
            "from": from_hash,
            "to": to_hash,
            "text": text,
            "outgoing": outgoing,
            "read": False
        }
        
        # Atomically append to file
        # Mode 'a' is atomic for single writes on POSIX systems
        msg_line = json.dumps(msg) + '\n'
        with open(self.messages_file, 'a') as f:
            f.write(msg_line)
            f.flush()  # Ensure written to disk
            os.fsync(f.fileno())  # Force OS to write to disk
    
    def _setup_identity(self):
        """Load or create Reticulum identity"""
        identity_path = Path(self.config["identity_path"])
        
        if identity_path.exists():
            self.identity = RNS.Identity.from_file(str(identity_path))
            self.logger.info(f"Loaded identity from {identity_path}")
        else:
            identity_path.parent.mkdir(parents=True, exist_ok=True)
            self.identity = RNS.Identity()
            self.identity.to_file(str(identity_path))
            self.logger.info(f"Created new identity at {identity_path}")
        
        identity_hash = clean_hash(self.identity.hash)
        self.logger.info(f"Identity hash: {identity_hash}")
    
    def _message_received_callback(self, lxmf_message):
        """Called when LXMF message is received"""
        try:
            source_hash = clean_hash(lxmf_message.source_hash)
            dest_hash = clean_hash(self.identity.hash)
            content = lxmf_message.content.decode('utf-8')
        except UnicodeDecodeError:
            self.logger.error("Received message with invalid UTF-8 encoding, skipping")
            return
        except ValueError as e:
            self.logger.error(f"Invalid hash in received message: {e}")
            return
        
        self.logger.info(f"Message from {source_hash}")
        
        # Log the message
        self._log_message(source_hash, dest_hash, content, outgoing=False)
        
        # Update active conversation if this is the first message or matches current
        if self.config["active_conversation"] is None or self.config["active_conversation"] == source_hash:
            self.config["active_conversation"] = source_hash
            self._save_config()
    
    def _setup_lxmf(self):
        """Initialize LXMF router and destination"""
        # Create the LXMF router
        self.router = LXMF.LXMRouter(
            identity=self.identity,
            storagepath=str(self.config_dir / "lxmf_storage")
        )
        
        # Register callback for incoming messages
        self.router.register_delivery_callback(self._message_received_callback)
        
        # Create our LXMF destination (this is what others will message)
        # This is equivalent to what NomadNet does
        self.destination = self.router.register_delivery_identity(self.identity, display_name="retimsg")
        
        # Save LXMF address to config so client can display it
        lxmf_address = clean_hash(self.destination.hash)
        self.config["lxmf_address"] = lxmf_address
        self._save_config()
        
        self.logger.info(f"LXMF router ready")
        self.logger.info(f"LXMF Address: {lxmf_address}")
    
    def _create_outbound_destination(self, dest_hash, dest_identity=None):
        """Create an outbound LXMF destination from a hash and optional identity"""
        if dest_identity is None:
            # No identity - create destination with just the hash
            dest = RNS.Destination(
                None,
                RNS.Destination.OUT,
                RNS.Destination.SINGLE,
                "lxmf", "delivery"
            )
            dest.hash = dest_hash
        else:
            # We have the identity
            dest = RNS.Destination(
                dest_identity,
                RNS.Destination.OUT,
                RNS.Destination.SINGLE,
                "lxmf", "delivery"
            )
        return dest
    
    def _handle_client_command(self, data):
        """Process command from client via socket"""
        try:
            cmd = json.loads(data)
            action = cmd.get("action")
            
            if action == "send":
                dest_hash_str = cmd.get("to")
                text = cmd.get("text")
                
                # Validate destination hash is provided
                if not dest_hash_str:
                    return json.dumps({"status": "error", "message": "Destination hash is required"})
                
                # Clean the hash (validates format)
                try:
                    dest_hash_str = clean_hash(dest_hash_str)
                except ValueError as e:
                    return json.dumps({"status": "error", "message": f"Invalid destination hash: {e}"})
                
                # Validate message size
                if not text or len(text) == 0:
                    return json.dumps({"status": "error", "message": "Message text cannot be empty"})
                
                if len(text.encode('utf-8')) > MAX_MESSAGE_SIZE:
                    return json.dumps({"status": "error", "message": f"Message too large (max {MAX_MESSAGE_SIZE} bytes)"})
                
                # Convert hex string to bytes
                try:
                    dest_hash = bytes.fromhex(dest_hash_str)
                except ValueError:
                    return json.dumps({"status": "error", "message": "Invalid destination hash format"})
                
                # Try to recall the identity
                dest_identity = RNS.Identity.recall(dest_hash)
                
                if dest_identity is None:
                    # Identity not known - request it for future use
                    RNS.Transport.request_path(dest_hash)
                
                # Create destination (works with or without identity)
                dest = self._create_outbound_destination(dest_hash, dest_identity)
                
                # Create LXMF message
                lxmf_message = LXMF.LXMessage(
                    dest,
                    self.destination,
                    text,
                    desired_method=LXMF.LXMessage.DIRECT
                )
                
                self.router.handle_outbound(lxmf_message)
                
                # Log outgoing message
                self._log_message(
                    clean_hash(self.identity.hash),
                    dest_hash_str,
                    text,
                    outgoing=True
                )
                
                # Update active conversation
                self.config["active_conversation"] = dest_hash_str
                self._save_config()
                
                return json.dumps({"status": "ok", "message": "Message sent"})
            
            elif action == "ping":
                return json.dumps({"status": "ok", "message": "daemon alive"})
            
            else:
                return json.dumps({"status": "error", "message": f"Unknown action: {action}"})
                
        except Exception as e:
            return json.dumps({"status": "error", "message": str(e)})
    
    def _run_socket_server(self):
        """Listen on Unix socket for client commands"""
        # Remove old socket if exists
        if self.socket_path.exists():
            self.socket_path.unlink()
        
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(str(self.socket_path))
        
        # Set socket permissions to owner-only (0600)
        os.chmod(self.socket_path, 0o600)
        
        sock.listen(1)
        sock.settimeout(1.0)  # Check for shutdown every second
        
        self.logger.info(f"Listening on {self.socket_path}")
        
        while self.running:
            try:
                conn, _ = sock.accept()
                # Limit data size to prevent DoS
                try:
                    data = conn.recv(MAX_SOCKET_DATA).decode('utf-8')
                except UnicodeDecodeError:
                    conn.send(json.dumps({"status": "error", "message": "Invalid UTF-8 in command"}).encode('utf-8'))
                    conn.close()
                    continue
                
                if data:
                    response = self._handle_client_command(data)
                    conn.send(response.encode('utf-8'))
                conn.close()
            except socket.timeout:
                continue
            except Exception as e:
                self.logger.error(f"Socket error: {e}")
        
        sock.close()
        if self.socket_path.exists():
            self.socket_path.unlink()
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals"""
        self.logger.info("Shutting down...")
        self.running = False
    
    def start(self):
        """Main daemon loop"""
        # Write PID file
        with open(self.pid_file, 'w') as f:
            f.write(str(os.getpid()))
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        
        self.logger.info("Starting RetiMsg Daemon...")
        
        # Initialize Reticulum
        self.reticulum = RNS.Reticulum()
        
        # Setup identity
        self._setup_identity()
        
        # Setup LXMF
        self._setup_lxmf()
        
        # Start socket server
        self.logger.info("Daemon ready")
        self._run_socket_server()
        
        # Cleanup
        if self.pid_file.exists():
            self.pid_file.unlink()
        self.logger.info("Daemon stopped")

if __name__ == "__main__":
    daemon = RetiMsgDaemon()
    daemon.start()

